* Source Block Execution
    There are several names associated with the ability to execute a source block from within an org document.
    The tech that backs most of this ability is called babel. It has as its primary goal the ideas of literate programming
    and reproducible research. What has made it a popular feature is the combination of babel with many of the other emacs features.

    [[https://orgmode.org/worg/org-contrib/babel/][Babel Active Code In OrgMode]]

    As some examples:

    - Using babel with tools like gnuplot, plantuml, ditaa and graphviz allows presenters to build diagrams dynamically from their notes.
    - The integration with tools like TRAMP in emacs allows developers to dynamically build reports from running processes on remote boxes.
    - Emacs ledger mode and the org mode spreadsheets have empowered some org mode users to build complex budget reports from their financial data.
    - Clocking and some of the project management tools in org mode have allowed contractors to dynamically build timesheets from work notes.

    Babel really made orgmode the original jupyt*r notebook.

** Basic Usage

    Babel treats a source block in an org document as an active function call that can be called in various ways.

    Here we have a basic python source block:

    #+BEGIN_EXAMPLE
      ##+BEGIN_SRC python :var x=5
        print(str(x))
      ##+END_SRC
    #+END_EXAMPLE

    There are a couple of things of note here:

    1. The source block states what language it belongs to, in this case python.
    2. We have specified a variable x that is set to the value of 5.
    3. We are able to access that variable from within the source block.

    Executing this source block will produce a #+RESULTS comment:

    #+BEGIN_EXAMPLE
     #+RESULTS:
     : 5
    #+END_EXAMPLE

** Variables
    Variables can come from a few different sources other than the source block fence itself.
    Variales can be in property blocks or property comments as seen below:

    #+BEGIN_EXAMPLE
      :PROPERTIES:
      :header-args:           :var g=global
      :header-args:python:    :var x=5
      :var: v=10
      :END: 

      #+PROPERTY: header-args: :var y=11
      #+PROPERTY: header-args:python: :var z=12
          
    #+END_EXAMPLE   

    Language specific variables can be defined as well using the language suffix

** Inputs
    While variables are nice, babel becomes even more useful when connected to data tables and lists in your documents.
    Tables and lists can both have a name. This name allows them to be referenced as the source of a variable.

    #+BEGIN_EXAMPLE
      #+NAME: my-source-block
      | name  | value |
      | Hello | 25    |
      | World | 42    |

      ##+BEGIN_SRC python :var DATA=my-source-block
        print(DATA)
      ##+END_SRC

      #+RESULTS:
      : [['name', 'value'], ['Hello', 25], ['World', 42]]
    #+END_EXAMPLE

** Execution Types
    Up till now we have been ignoring one of the important parts of babel which is the execution type.
    Babel supports 2 execution modes:

    - Output - This is the default and what we have seen so far. The stdout of a source block is captured and used as the return value.
    - Value - This is more the traditional function call style. 

    #+BEGIN_EXAMPLE
      ##+BEGIN_SRC python :results value
        return 5     
      ##+END_SRC   

      #+RESULTS:
      : 5
    #+END_EXAMPLE

** Results

    The results keyword really has 4 dimensions
    - Execution Type :: output vs value - what do we capture?
    - Output Handling :: table vs list vs raw - does the output get interpreted as something else?
    - Formatting :: verbatim vs html vs org vs drawer vs code - do we wrap the output in something?
    - Output Mode :: append vs prepend vs silent vs replace - how do we insert the output into the buffer?

    Each results keyword can have a combination of those 4.
    #+BEGIN_EXAMPLE
    ##+BEGIN_SRC python :results output table drawer
      print("Hello World")
    ##+END_SRC

    #+RESULTS:
    :results:
    | Hello | World |
    :end:
    #+END_EXAMPLE

    Here we have formatted the output as a table and put it in a drawer.
    You can also output the results to a file with the :file <filename> parameter.

    Here is some powershell doing the same thing as our python
 
    #+BEGIN_EXAMPLE
    #+NAME: in-table
    | a | b | c | d | e |
    | 1 | 2 | 3 | 4 | 5 |
    | 6 | 7 | 8 | 9 | 0 |
   
    ##+BEGIN_SRC powershell :var DATA=in-table :results table
     $DATA | %{"$_"}
    ##+END_SRC

    #+RESULTS:
    | a | b | c | d | e |
    | 1 | 2 | 3 | 4 | 5 |
    | 6 | 7 | 8 | 9 | 0 |
      
    #+END_EXAMPLE
** Call 

    Org Mode treats source blocks like functions in some strange programming language tapestry.
    The call statements lets you call a source block with a different set of parameters. Executing one of these
    blocks will produce a new set of results below the call, but with the alternate set of parameters.

    #+BEGIN_SRC org
      #+CALL: name-to-call(x=5)
    #+END_SRC

** Chaining Source Blocks

    Variable inputs can not only be tables, lists or plain old data types but they can be other named source blocks.
    Here is a silly example. In this little example the second source block will have "hi" as its output. It has chained
    the results into x and used that variable in the print statement.

    #+BEGIN_EXAMPLE
      ##+NAME: my-function
      ##+BEGIN_SRC python
          print("hi")
      ##+END_SRC

      ##+BEGIN_SRC python :var x=my-function
          print(x)
      ##+END_SRC
    #+END_EXAMPLE

    This can be really powerful for situations where you have one language well suited for a certain kind of data manipulation.
    For example, you use powershell to pull some data from azure. You then pipe that data into a little python script that manipulates
    it. Finally you push the output of the python script into a gnuplot source block and graph it to visualize what is going on.

** Full Circle SBE

    Things get even more interesting once we start to look at the sbe (Source Block Execute) table function. With this we come full circle. 
    Not only can tables act as inputs to source blocks but source blocks can act as inputs to tables.

    Remember that example in the chaining section above? We chained hi from the output of one source block into a variable
    and used it as input. Here we are calling that same block but providing a different input. Here the input is just a string.
    The result then gets inserted into my table. I can even pass cell references from the table as parameters to those functions.

    #+BEGIN_EXAMPLE
    | pulled from python |
    | hello world        |
    #+TBLFM:@2$1=sbe('my-function',x="hello world")
    #+END_EXAMPLE

** Tangle and Export

    Literate programming and reproducible research require several things:

    1. You can easily publish your document.
    2. You can easily have someone else run your source code with your data.
    3. All of your code and data can live in one seamless package.

    These things are supported by the 3 core pillars of babel:

    - Execute :: Run a source block inline in my code.
    - Tangle :: Extract my source code with embeded data into pure source.
    - Export :: Export my document to another format.

    - Execute we have already been covering at length in this document.
    - Export is supported by our html exporter, the reveal js exporter for presentations and pandoc for conversion to a ton of other formats.
    - Finally tangling is supported by our detangler. *Org Tangle File* will attempt to create pure source files that can be executed in their various forms.

** NoWeb
    One final tool makes the literate programming toolset complete. This is some support for the NoWeb macro language. Much like macros in
    C or C++ NoWeb lets you paste either your source code between source blocks OR the results of the execution of the source block.